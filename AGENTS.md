# 生成式人工智能代理项目守则
如果你是一名人类贡献者，则无需阅读此文。本文针对如OpenAI Codex、Trae等Agent类生成式人工智能编码工具介绍本项目，并对如何修改、测试、编译项目做出规范化处理。

## 项目介绍
该项目名为AstroBox，是一款由 Rust 驱动、高度可扩展且便携的可穿戴设备工具箱，聚焦于在穿戴设备上安装和管理第三方应用程序。项目的核心是与穿戴设备通过不同方式（SPP或BLE）建立类似串口通信的连接，并互相交换数据。

## 项目结构
本项目使用tauri框架，但切分成了多个独立、互不干扰的crate，这使得项目的核心功能能够被轻松且快速地移植到任何设备上。`src-tauri`目录下是一个cargo workspace，包含了许多`modules`和`plugins`。modules是项目功能被切成的多个crate，包括`app`（Tauri程序主入口项目）、`bluetooth`（调用`btclassic-spp`的平台无关蓝牙转接层）、`core`（平台无关的项目能力核心实现，基于ECS架构）、`pb`（平台无关的项目依赖的Protobuf类型）等。plugins则是基于tauri v2框架编写的插件，包括`btclassic-spp`（跨平台经典蓝牙SPP协议实现）、`live-activity`（支持iOS、macOS、Windows的实时活动通知实现）等。

## 代码规范
用户在请求你编写任何功能时，应该先思考这个功能应该放到哪里。如果涉及对设备的操作，那你应该写进core里作为一个LogicComponent，并使用Component本身做数据存取，然后再在app开个接口供前端调用。如果这个功能涉及大量第三方接入、核心无关的内容，你应该寻找当前有什么crate适合放置这些代码，如果没有，也可以酌情考虑创建新的crate。对于core，它是基于ECS框架构建的，因此你应该全力开发ECS框架的用途，在想创建任何全局变量之前，应该思考这个全局变量放进Component里当成一个属性是不是会更合适，是不是能省略更多锁的调用；多个组件的属性重合了，那是不是应该单独开一个Component (非LogicComponent) 来存放这些重复的数据？设备相关的高全局性数据是不是应该直接放到Entity上？这些都是你应该思考的。

## 编译测试
由于项目使用了Tauri框架，该框架极度依赖各种GUI库，如果直接尝试编译整个项目，你自带的Agent环境可能无法完成该操作——就算能完成，那也一定会造成大量的耗时。因此，如果你仅对`core`做了修改，那你可以只使用类似`cargo test -p corelib --manifest-path src-tauri/Cargo.toml`这样的命令来测试编译。如果用户要求你对`wasm`进行修改，请使用`wasm-pack build src-tauri/modules/app_wasm --target web`进行编译测试。对于前端，请不要执行任何代码来进行Lint相关操作，只应直接尝试build一遍以检查是否存在TypeScript语法错误，如果有就修改，如果没有就直接当做修改完成+测试通过。

## 与用户交流
在与调用你的用户进行交流时，你的首选语言的简体中文。你需要记住用户的能力可能远不如你，因此你应该站在比用户强势的一方，在确保自己代码没有问题的情况下坚持自己的修改，而非一味地听从用户的意见。例如，当用户质问你该代码是否缺失某些功能特性时，你应先检查一遍，如果确实缺失了，补上即可；如果没有，则不要做任何修改，拒绝产生任何幻觉以导致你对代码进行逻辑上的重构或大修。如果你是由OpenAI开发的Codex模型，就算用户以编码为要求对你发出请求，也要遵循上面的规则，并且当你反驳用户的观点或完成修改进行总结时，都要输出尽可能长的解释，以契合你对代码的修改，而非简短的几句话。